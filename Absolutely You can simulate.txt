Absolutely! You **can** simulate driver data and test your system using Docker Compose. Here’s a concise plan and some options for how to do it:

---

## 1. **What You Want to Simulate**
- Multiple drivers sending location, status, and vehicle data (as if they’re in a zone).
- Data sent to your backend (could be via REST API, WebSocket, or MQTT, depending on your stack).

---

## 2. **How to Simulate**
### **Option A: Use a Simple Python/Node.js Script as a Data Generator**
- Write a script that mimics driver clients.
- The script can send HTTP requests or WebSocket messages to your backend at intervals.
- You can run multiple instances of this script in Docker Compose to simulate many drivers.

### **Option B: Use Existing Tools**
- **[Mockoon](https://mockoon.com/)**: For mocking REST APIs.
- **[mqtt-bench](https://github.com/gaochun/mqtt-bench)**: For MQTT load testing.
- **[Locust](https://locust.io/)**: For HTTP/WebSocket user simulation.

---

## 3. **Example: Docker Compose with Python Driver Simulator**

**docker-compose.yml**
```yaml
version: '3.8'
services:
  backend:
    image: your-backend-image
    ports:
      - "8080:8080"
    # ... other config

  driver-simulator:
    build: ./driver-simulator
    environment:
      - BACKEND_URL=http://backend:8080/api/driver/update
    depends_on:
      - backend
    scale: 10  # Simulate 10 drivers (use `docker compose up --scale driver-simulator=10`)
```

**driver-simulator/Dockerfile**
```dockerfile
FROM python:3.11
WORKDIR /app
COPY simulator.py .
RUN pip install requests
CMD ["python", "simulator.py"]
```

**driver-simulator/simulator.py**
```python
import os, time, random, requests

BACKEND_URL = os.environ.get('BACKEND_URL', 'http://localhost:8080/api/driver/update')
DRIVER_ID = random.randint(1000, 9999)

def random_location():
    # Example: somewhere in Nairobi
    lat = -1.28 + random.uniform(-0.01, 0.01)
    lon = 36.82 + random.uniform(-0.01, 0.01)
    return lat, lon

while True:
    lat, lon = random_location()
    data = {
        "driverId": DRIVER_ID,
        "lat": lat,
        "lon": lon,
        "status": random.choice(["ACTIVE", "BREAK", "OFFLINE"]),
        "vehicleId": random.randint(1, 10)
    }
    print(f"Sending: {data}")
    try:
        requests.post(BACKEND_URL, json=data)
    except Exception as e:
        print("Error:", e)
    time.sleep(random.uniform(1, 5))
```

---

## 4. **How to Run**
1. Build and start with Docker Compose:
   ```sh
   docker compose up --build --scale driver-simulator=10
   ```
2. Your backend will receive simulated driver data as if from 10 drivers in a zone.

---

## 5. **What You Can Test**
- Real-time map updates.
- Backend load handling.
- Notification and alert systems.
- KPI and dashboard updates.

---

## 6. **Tips**
- Adjust the script to match your backend’s expected API.
- You can add more fields (speed, fuel, etc.) as needed.
- For more realism, use real route coordinates or replay real data.

---

**Let me know if you want a ready-to-use repo structure or a more advanced simulation (e.g., with WebSockets or MQTT)!**





ENhancement
Fantastic! You’re on the right track—your context and stack are perfect for this kind of simulation.

### **Tailoring the Simulation for Your Stack**

Given your backend uses a **WebSocket endpoint** (`/tracking`) for real-time driver location updates (see `TrackingEndpoint.java`), you should simulate drivers using **WebSocket clients** rather than HTTP POSTs. This will more closely mimic real driver app behavior and let you test the full real-time pipeline, including admin map updates and geofence logic.

---

## **How to Simulate Driver WebSocket Clients**

### **1. Python WebSocket Client Example**

**driver-simulator/simulator.py**
```python
import os, time, random, json, websocket

WS_URL = os.environ.get('WS_URL', 'ws://backend:8080/Nganya/tracking')
DRIVER_ID = os.environ.get('DRIVER_ID', str(random.randint(1000, 9999)))

def random_location():
    # Example: somewhere in Nairobi
    lat = -1.28 + random.uniform(-0.01, 0.01)
    lon = 36.82 + random.uniform(-0.01, 0.01)
    return lat, lon

def make_message():
    lat, lon = random_location()
    return json.dumps({
        "lat": lat,
        "lng": lon,
        "driverId": DRIVER_ID,
        "status": random.choice(["ACTIVE", "BREAK", "OFFLINE"]),
        "vehicleId": random.randint(1, 10)
    })

def on_open(ws):
    print(f"Driver {DRIVER_ID} connected")
    def run(*args):
        while True:
            msg = make_message()
            ws.send(msg)
            print(f"Sent: {msg}")
            time.sleep(random.uniform(1, 5))
    import _thread
    _thread.start_new_thread(run, ())

if __name__ == "__main__":
    ws = websocket.WebSocketApp(
        WS_URL,
        on_open=on_open
    )
    ws.run_forever()
```

**driver-simulator/Dockerfile**
```dockerfile
FROM python:3.11
WORKDIR /app
COPY simulator.py .
RUN pip install websocket-client
CMD ["python", "simulator.py"]
```

**docker-compose.yml**
```yaml
version: '3.8'
services:
  backend:
    image: your-backend-image
    ports:
      - "8080:8080"
    # ... other config

  driver-simulator:
    build: ./driver-simulator
    environment:
      - WS_URL=ws://backend:8080/Nganya/tracking
    depends_on:
      - backend
    # Use --scale to simulate multiple drivers
```

**Run with:**
```sh
docker compose up --build --scale driver-simulator=10
```

---

### **2. What This Will Do**
- Each simulator container acts as a driver, connecting to your `/tracking` WebSocket endpoint.
- It sends random location/status data every few seconds.
- Your backend and admin dashboard will see these as real drivers moving around Nairobi.

---

### **3. What You Can Observe**
- **Real-time map updates** on the admin dashboard.
- **Geofence triggers** and notifications.
- **Backend performance** under simulated load.
- **WebSocket session handling** (open/close, error cases).

---

### **4. Tips**
- You can add more fields (speed, fuel, etc.) to the message as needed.
- For more realism, use a list of real route coordinates and iterate through them.
- You can also simulate drivers disconnecting/reconnecting.

---

**If you want a ready-to-use repo structure or a more advanced simulation (e.g., with authentication, MQTT, or replaying real trip data), just ask!**

